use ark_std::cfg_into_iter;
use ark_bls12_381::Fr;
use ark_ff::Field;
use ark_poly::polynomial::multivariate::{SparseTerm, Term};
use ark_poly::polynomial::DenseMVPolynomial;
use crate::sumcheck::{UniPoly,MultyPoly, n_to_vec};

#[derive(Debug, Clone)]
pub struct Prover{
    pub g: MultyPoly,//The multivariate polynomial
    pub r_vec: Vec<Fr>, //This is a growing vector; it grows within rounds
}
impl Prover{
    pub fn initialize(g: &MultyPoly)->Self{
        Prover { g: g.clone(), r_vec: vec![] }}
    /// This function takes as input the random value (generated by the verifier at the j-th round) and it outputs
    /// the univariant polinomial g_j(x_j)
fn evaluate_gj(&self, points: Vec<Fr>)->UniPoly{
    cfg_into_iter!(self.g.terms()).fold(
        UniPoly::from_coefficients_vec(vec![]),
        |sum,(coeff,term)| {
            let (coeff_eval, letteral_part)=self.eval_term(term, &points);
            let curr = match letteral_part {
                None=>UniPoly::from_coefficients_vec(vec![(0,coeff*&coeff_eval)]),//this is a costant term:
                _=>UniPoly::from_coefficients_vec(vec![(letteral_part.unwrap().degree(),coeff*&coeff_eval)])
                
            };
            sum+curr
        })
}
/// This funtion outputs the evaluation of the letteral part of the monomial (term) 
/// of the multivariate polinomial. Assume we are in the j-th round,
/// thus we have r_vec =(r_0,..,r_j-1) and we substitute r_0,..r_j-1 into the 
/// variables x_0..x_j-1, we leave the j-th variable fixed as x and we evaluate
/// the remainig variables with the point given in input.
/// 
/// # Examples
///
/// ```
/// use ark_ff::BigInt;
/// 
/// use ark_std::{One,Zero};
/// use ark_ff::Field;
/// use ark_bls12_381::Fr;
/// use ark_poly::polynomial::multivariate::{SparsePolynomial, SparseTerm, Term};
/// use ark_poly::polynomial::{DenseMVPolynomial, Polynomial};
/// use ark_poly::univariate::SparsePolynomial as UniSparsePolynomial;
/// use sumcheck::prover::Prover;
/// 
/// let poly: SparsePolynomial<Fr,SparseTerm>= SparsePolynomial::from_coefficients_vec(
/// 3,
/// vec![
///     (Fr::from(2), SparseTerm::new(vec![(0, 3)])),
///     (Fr::from(1), SparseTerm::new(vec![(0, 1), (2, 1)])),
///     (Fr::from(1), SparseTerm::new(vec![(1, 1), (2, 1)])),
/// ],
/// );
/// let mut prover=Prover::initialize(&poly);
/// prover.r_vec.push(Fr::from(3));
/// let points=[Fr::one(),Fr::from(2)].to_vec();
/// let term=&poly.terms[0].1;
/// let (coef,var)= (Fr::from(2), Some(SparseTerm::new(vec![(1,1)])));
/// assert_eq!(prover.eval_term(&term,&points),(coef,var));
/// 
/// ```
/// 

pub fn eval_term(&self, term:&SparseTerm,points: &Vec<Fr>)->(Fr,Option<SparseTerm>){
    if points.len()!=self.g.num_vars() - self.r_vec.len() {panic!("Error! The length of the input vector must be equal to self.g.num_vars() - self.r_vec.len()");}
    let mut fixed_term:Option<SparseTerm>=None; //initialize fixed_term to none
    let coeff:Fr=cfg_into_iter!(term).fold(1u32.into(),|product,(var,exp)| match *var {
        /*j is the j-th variable*/
        j if j==self.r_vec.len()=>{
                fixed_term=Some(SparseTerm::new(vec![(j,*exp)]));
                product }
        j if j<self.r_vec.len()=>{ 
                self.r_vec[j].pow(&[*exp as u64])*product}
    _=> points[*var-self.r_vec.len()].pow(&[*exp as u64])*product});
    (coeff,fixed_term)
}
pub fn gen_unipoly(&mut self,r:Option<Fr>)->UniPoly{

    if r.is_some() {
        self.r_vec.push(r.unwrap());
      }
      let v = self.g.num_vars() - self.r_vec.len();
      /*Now we evaluate on the hypercube {0,1}^v */
      (0..1<<(v-1)).fold(
        UniPoly::from_coefficients_vec(vec![(0, 0u32.into())]),
        |sum, n| sum + self.evaluate_gj(n_to_vec(n as usize,v)),
      )
    }
}