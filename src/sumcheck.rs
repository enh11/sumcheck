use ark_ff::Field;
use ark_bls12_381::Fr;
use ark_poly::polynomial::multivariate::{SparsePolynomial, SparseTerm, Term};
use ark_poly::polynomial::{DenseMVPolynomial, Polynomial};
use ark_poly::univariate::SparsePolynomial as UniSparsePolynomial;
use ark_std::cfg_into_iter;
use rand::Rng;


pub type MultyPoly= SparsePolynomial<Fr, SparseTerm>; //This is for the original polinomial g
pub type UniPoly = UniSparsePolynomial<Fr>; // This is for the polinomial gj generated in the j-th round

#[derive(Debug, Clone)]
pub struct Prover{
    pub g: MultyPoly,//The multivariate polynomial
    pub r_vec: Vec<Fr>, //This is a growing vector; it grows within rounds
}
impl Prover{
    pub fn initialize(g: &MultyPoly)->Self{
        Prover { g: g.clone(), r_vec: vec![] }}
    /// This function takes as input the random value (generated by the verifier at the j-th round) and it outputs
    /// the univariant polinomial g_j(x_j)
    pub fn gen_unipoly(&mut self,r:Option<Fr>)->UniPoly{

if r.is_some() {
    self.r_vec.push(r.unwrap());
  }
  let v = self.g.num_vars() - self.r_vec.len();
  (0..(2u32.pow(v as u32 - 1))).fold(
    UniPoly::from_coefficients_vec(vec![(0, 0u32.into())]),
    |sum, n| sum + self.evaluate_gj(n_to_vec(n as usize,v)),
  )
}
fn evaluate_gj(&self, points: Vec<Fr>)->UniPoly{
    cfg_into_iter!(self.g.terms()).fold(
        UniPoly::from_coefficients_vec(vec![]),
        |sum,(coeff,term)| {
            let (coeff_eval, letteral_part)=self.eval_term(term, &points);
            let curr = match letteral_part {
                None=>UniPoly::from_coefficients_vec(vec![(0,coeff*&coeff_eval)]),
                _=>UniPoly::from_coefficients_vec(vec![(letteral_part.unwrap().degree(),coeff*&coeff_eval)])
                
            };
            sum+curr
        })
}
fn eval_term(&self, term:&SparseTerm,points: &Vec<Fr>)->(Fr,Option<SparseTerm>){
    /*this funtion outputs the evaluation of the letteral part of the monomial (term) 
    by substituting values of points*/
    let mut fixed_term:Option<SparseTerm>=None; //initialize fixed_term to none
    let coeff:Fr=cfg_into_iter!(term).fold(1u32.into(),|product,(var,exp)| match *var {
        /*j is the j-th variable*/
        j if j==self.r_vec.len()=>{
                fixed_term=Some(SparseTerm::new(vec![(j,*exp)]));
                product }
        j if j<self.r_vec.len()=>{ 
                self.r_vec[j].pow(&[*exp as u64])*product}
    _=> points[*var-self.r_vec.len()].pow(&[*exp as u64])*product});
    

    (coeff,fixed_term)
}
}

/*The verifier is represented by the following */
pub struct Verifier{
    pub g: MultyPoly,//The original polinomial
    pub check_value:Fr
}
impl Verifier {
    pub fn initialize(g:&MultyPoly,v:Fr)->Self{
        Verifier { g: g.clone(), check_value: v }
    }
    pub fn get_random(&self)->Option<Fr> {
        let mut rng = rand::thread_rng();
        let r: Fr = rng.gen();
        Some(r)
    }
    pub fn degrees_look_up(&self)->Vec<usize>{
        let mut lookup:Vec<usize>=vec![0;self.g.num_vars()];
        cfg_into_iter!(self.g.terms()).for_each(|(_,term)| {
            cfg_into_iter!(term).for_each(|(var,exp)|{
                if *exp>lookup[*var]{lookup[*var]=*exp}
        });
        });
        lookup
    }    
}
pub fn n_to_vec(i:usize,v:usize)->Vec<Fr>{
    format!("{:0>width$}", format!("{:b}", i), width = v)
		.chars()
		.map(|x| if x == '1' { 1.into() } else { 0.into() })
		.collect()}

pub fn slow_sum_g(g:&MultyPoly)->Fr {
    let v=g.num_vars();
    (0..1<<v).map(|x| g.evaluate(&n_to_vec(x as usize, v))).sum()
    }

pub fn sum_check(g:MultyPoly,v:Fr)->bool{
    let mut pr=Prover::initialize(&g);
    let vr=Verifier::initialize(&g, v);
    /*This is the starting round. The prover calculate g_0 */
    let mut g_i=pr.gen_unipoly(None); /*Prover sends g_0 to Verifier */
    let expected_value= g_i.evaluate(&Fr::from(0))+g_i.evaluate(&Fr::from(1));
    let degrees=vr.degrees_look_up();
    assert_eq!(expected_value,v);
    assert!(g_i.degree() <= degrees[0]);
    println!("Round 0 ok!");
    let mut r: Option<ark_ff::Fp<ark_ff::MontBackend<ark_bls12_381::FrConfig, 4>, 4>>;/*Verifier gets a random element in the field and sends it to prover */
    let mut expected_value:Fr;/*Verifier calculate g_i(r); this is the next value to be checked */
    let mut v:Fr;
    for i in 1..g.num_vars{
        r= vr.get_random();
        expected_value=g_i.evaluate(&Fr::from(r.unwrap()));
        g_i=pr.gen_unipoly(r);
        v=g_i.evaluate(&Fr::from(0))+g_i.evaluate(&Fr::from(1));
        assert_eq!(expected_value,v);
        assert!(g_i.degree()<=degrees[i]);
        println!("Round {} ok!",i);
        }
    r=vr.get_random();
    pr.r_vec.push(r.unwrap());
    expected_value=g_i.evaluate(&Fr::from(r.unwrap()));
    v=pr.g.evaluate(&pr.r_vec);
    assert_eq!(expected_value,v);
    println!("Final round ok!");
    true

}
#[cfg(test)]
mod tests {
    use ark_bls12_381::Fr;
    use ark_ff::{MontBackend, Fp};
    use ark_poly::{multivariate::{SparsePolynomial, SparseTerm, Term}, DenseMVPolynomial};

    use crate::sumcheck::slow_sum_g;

    #[test]
    fn test_slow_sum() {

        let poly: SparsePolynomial<Fp<MontBackend<ark_bls12_381::FrConfig, 4>, 4>, SparseTerm> = SparsePolynomial::from_coefficients_vec(
            3,
            vec![
                (Fr::from(2), SparseTerm::new(vec![(0, 3)])),
                (Fr::from(1), SparseTerm::new(vec![(0, 1), (2, 1)])),
                (Fr::from(1), SparseTerm::new(vec![(1, 1), (2, 1)])),
            ],
        );

        let h = slow_sum_g(&poly);
        assert_eq!(h, 12.into());
    }
}
